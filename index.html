<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dash Pro ‚Äî niveles tipo Geometry Dash</title>
  <style>
    :root{
      --bg1:#070b1a; --bg2:#0a1330;
      --panel:#0b1634cc; --stroke:#ffffff22;
      --text:#e9f0ff; --muted:#b9c8ffcc;
      --good:#38d39f; --warn:#ffcc66; --bad:#ff5b6e;
      --btn:#172a5a; --btn2:#1e3a8a;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:var(--text);
      background: radial-gradient(1200px 900px at 20% 10%, #1b2a66 0%, transparent 60%),
                  radial-gradient(900px 700px at 70% 40%, #17357a 0%, transparent 55%),
                  linear-gradient(180deg, var(--bg2), var(--bg1));
      min-height:100vh; display:flex; justify-content:center;
    }
    .wrap{width:min(1120px, 96vw); padding:18px 0 26px}
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px; border:1px solid var(--stroke);
      background:linear-gradient(180deg, #0f1b3bcc, #08102acc);
      border-radius:14px;
      box-shadow: 0 10px 35px #00000055;
    }
    .title{display:flex; gap:10px; align-items:center; font-weight:800; letter-spacing:.2px;}
    .title small{display:block; font-weight:600; color:var(--muted); margin-top:2px}
    .pill{
      display:inline-flex; gap:10px; align-items:center;
      padding:8px 10px; border:1px solid var(--stroke);
      border-radius:999px; background:#0b1634aa;
      color:var(--muted); font-size:13px;
    }
    .pill b{color:var(--text)}
    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
    .panel{
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, #0b1634cc, #07112ccc);
      border-radius:18px;
      box-shadow: 0 14px 40px #00000055;
      overflow:hidden;
    }
    .panel h3{
      margin:0; padding:12px 14px;
      border-bottom:1px solid var(--stroke);
      font-size:14px; letter-spacing:.4px; color:var(--muted);
      display:flex; align-items:center; justify-content:space-between;
    }
    .panel .body{padding:14px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    button, select, input[type="range"]{font:inherit;}
    button{
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      box-shadow: 0 10px 22px #00000055;
    }
    button:hover{filter:brightness(1.08)}
    button:active{transform:translateY(1px)}
    button.secondary{background:linear-gradient(180deg, #0f1f49, #0b1533);}
    button.danger{background:linear-gradient(180deg, #a1122c, #5b0d1c);}
    select{
      border:1px solid var(--stroke);
      background:#0b1634;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      min-width: 240px;
    }
    .kpi{
      display:grid; grid-template-columns: repeat(4,1fr);
      gap:10px; margin-top:10px;
    }
    @media (max-width: 560px){ .kpi{grid-template-columns: repeat(2,1fr)} }
    .card{
      border:1px solid var(--stroke);
      background:#0b1634aa;
      border-radius:14px;
      padding:10px 12px;
    }
    .card .label{color:var(--muted); font-size:12px}
    .card .value{font-weight:800; font-size:18px; margin-top:4px}
    .value.good{color:var(--good)}
    .value.warn{color:var(--warn)}
    .value.bad{color:var(--bad)}
    canvas{
      width:100%; height:520px;
      background:linear-gradient(180deg, #07112c, #040815);
      border-radius:16px;
      display:block;
      border:1px solid var(--stroke);
    }
    .hint{color:var(--muted); font-size:13px; line-height:1.35}
    .sep{height:1px; background:var(--stroke); margin:12px 0}
    .control{
      display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center;
      margin:10px 0;
    }
    .control label{color:var(--muted); font-size:13px}
    input[type="range"]{width:100%}
    .mini{
      font-size:12px; color:var(--muted);
      border:1px solid var(--stroke);
      padding:6px 8px; border-radius:10px; background:#0b1634aa;
      min-width:62px; text-align:center;
    }

    /* Modal men√∫ */
    .overlay{
      position:fixed; inset:0;
      background:#00000088;
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(820px, 96vw);
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, #0f1b3bee, #07112cee);
      border-radius:18px;
      box-shadow: 0 20px 80px #000000aa;
      overflow:hidden;
    }
    .modal header{
      border:none; border-radius:0;
      background:transparent;
      box-shadow:none;
      border-bottom:1px solid var(--stroke);
    }
    .modal .content{padding:14px}
    .levels{
      display:grid; grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    @media (max-width: 720px){ .levels{grid-template-columns: 1fr} }
    .lvl{
      border:1px solid var(--stroke);
      background:#0b1634aa;
      border-radius:14px;
      padding:12px;
      cursor:pointer;
    }
    .lvl:hover{filter:brightness(1.08)}
    .lvl h4{margin:0 0 6px 0}
    .tag{
      display:inline-block;
      font-size:12px; color:#0b1634;
      background:var(--warn);
      padding:3px 8px; border-radius:999px;
      font-weight:800;
      margin-left:8px;
    }
    .footerRow{
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      padding:12px 14px; border-top:1px solid var(--stroke);
      background:#06102aaa;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
      padding:2px 6px;
      border:1px solid var(--stroke);
      border-bottom-color:#00000088;
      background:#0b1634aa;
      border-radius:8px;
      color:var(--muted);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <div style="font-size:18px">‚¨õ Dash Pro</div>
        <div>
          <div style="font-size:14px; font-weight:800">‚Äî niveles tipo Geometry Dash</div>
          <small>
            Saltar / acci√≥n: <span class="kbd">Espacio</span> / <span class="kbd">‚Üë</span> / toque ¬∑
            Pausa: <span class="kbd">P</span> ¬∑ Men√∫: <span class="kbd">M</span> ¬∑ Reiniciar: <span class="kbd">R</span>
          </small>
        </div>
      </div>

      <div class="pill">
        <span>Nivel: <b id="uiLevelName">‚Äî</b></span>
        <span>Modo: <b id="uiPlayerMode">CUBE</b></span>
        <span>Estado: <b id="uiState" style="color:var(--good)">MEN√ö</b></span>
      </div>
    </header>

    <div class="grid">
      <div class="panel">
        <h3>
          <span>Juego</span>
          <div class="row">
            <button id="btnMenu" class="secondary">üè† Men√∫</button>
            <button id="btnPause" class="secondary">‚è∏ Pausa</button>
            <button id="btnRestart" class="danger">‚Üª Reiniciar</button>
          </div>
        </h3>
        <div class="body">
          <canvas id="cv" width="1100" height="520"></canvas>

          <div class="kpi">
            <div class="card">
              <div class="label">Progreso</div>
              <div class="value good" id="uiProgress">0%</div>
            </div>
            <div class="card">
              <div class="label">Intentos</div>
              <div class="value" id="uiAttempts">0</div>
            </div>
            <div class="card">
              <div class="label">Velocidad</div>
              <div class="value warn" id="uiSpeed">‚Äî</div>
            </div>
            <div class="card">
              <div class="label">Gravedad</div>
              <div class="value warn" id="uiGravity">‚Äî</div>
            </div>
          </div>

          <div class="sep"></div>
          <div class="hint">
            üîß Ajustes en tiempo real: si ‚Äúva muy r√°pido‚Äù o ‚Äúgravedad muy alta‚Äù, aqu√≠ lo arreglamos sin tocar el motor.<br/>
            Nota: en <b>SHIP</b> mant√©n pulsado para subir. En <b>WAVE</b> mant√©n para subir / suelta para bajar.
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>
          <span>Ajustes r√°pidos</span>
          <span class="hint">sin romper nada</span>
        </h3>
        <div class="body">
          <div class="control">
            <label>Velocidad del nivel (px/s)</label>
            <div class="mini" id="uiSpeedBox">340</div>
            <input id="speedRange" type="range" min="240" max="520" value="340" />
          </div>

          <div class="control">
            <label>Gravedad (px/s¬≤)</label>
            <div class="mini" id="uiGravBox">1650</div>
            <input id="gravRange" type="range" min="0" max="2600" value="1650" />
          </div>

          <div class="control">
            <label>Altura de salto (impulso)</label>
            <div class="mini" id="uiJumpBox">520</div>
            <input id="jumpRange" type="range" min="0" max="720" value="520" />
          </div>

          <div class="sep"></div>

          <div class="row">
            <select id="levelSelect"></select>
            <button id="btnPlay">‚ñ∂ Jugar</button>
          </div>

          <div class="sep"></div>

          <div class="hint">
            üìå Tipos soportados: <b>spike</b>, <b>block</b>, <b>platform</b>, <b>orb</b>, <b>mode</b>.<br/>
            Modo: <b>cube</b>, <b>ship</b>, <b>ball</b>, <b>ufo</b>, <b>wave</b>.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- MEN√ö -->
  <div class="overlay" id="menuOverlay">
    <div class="modal">
      <header>
        <div class="title">
          <div style="font-size:18px">üèÅ Selector de niveles</div>
          <div>
            <small>Elige un nivel. Luego dale a ‚ÄúJugar nivel‚Äù.</small>
          </div>
        </div>
        <div class="row">
          <button id="btnCloseMenu" class="secondary">Cerrar</button>
        </div>
      </header>

      <div class="content">
        <div class="levels" id="levelsGrid"></div>
      </div>

      <div class="footerRow">
        <button id="btnMenuPlay">‚ñ∂ Jugar nivel</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ==========================================================
  //  NIVELES (incluye orbes + modos: ship/ball/ufo/wave/cube)
  // ==========================================================
  const LEVELS = [
    {
      id: "easy-1",
      name: "Nivel 1 ‚Äî F√°cil",
      diff: "F√ÅCIL",
      desc: "Ritmo b√°sico. Espacios amplios. Nada imposible.",
      speed: 340,
      gravity: 1650,
      jump: 520,
      length: 2600,
      obstacles: [
        {type:"spike", x: 520, w:36, h:36},
        {type:"block", x: 860, w:54, h:54},
        {type:"spike", x: 1180, w:36, h:36},
        {type:"spike", x: 1450, w:36, h:36},
        {type:"block", x: 1750, w:54, h:54},
        {type:"spike", x: 2120, w:36, h:36},
      ]
    },
    {
      id: "easy-2",
      name: "Nivel 2 ‚Äî F√°cil+",
      diff: "F√ÅCIL",
      desc: "A√±ade plataformas y combos suaves.",
      speed: 360,
      gravity: 1700,
      jump: 540,
      length: 3200,
      obstacles: [
        {type:"spike", x: 520, w:36, h:36},
        {type:"block", x: 900, w:54, h:54},
        {type:"platform", x: 1240, w:240, h:22, yOffset: -120},
        {type:"spike", x: 1560, w:36, h:36},
        {type:"spike", x: 1800, w:36, h:36},
        {type:"block", x: 2100, w:54, h:54},
        {type:"platform", x: 2460, w:260, h:22, yOffset: -170},
        {type:"spike", x: 2800, w:36, h:36},
      ]
    },
    {
      id: "mid-1",
      name: "Nivel 3 ‚Äî Medio",
      diff: "MEDIO",
      desc: "Ritmo m√°s r√°pido. Requiere timing (pero justo).",
      speed: 400,
      gravity: 1800,
      jump: 560,
      length: 3600,
      obstacles: [
        {type:"spike", x: 520, w:36, h:36},
        {type:"spike", x: 820, w:36, h:36},
        {type:"block", x: 1120, w:54, h:54},
        {type:"platform", x: 1440, w:220, h:22, yOffset: -140},
        {type:"spike", x: 1760, w:36, h:36},
        {type:"block", x: 2050, w:54, h:54},
        {type:"spike", x: 2300, w:36, h:36},
        {type:"platform", x: 2620, w:260, h:22, yOffset: -190},
        {type:"spike", x: 3020, w:36, h:36},
        {type:"spike", x: 3320, w:36, h:36},
      ]
    },

    // ==== tus niveles con orbes + modos (arreglados para este motor)
    {
      id: "orb-4",
      name: "Nivel 4 ‚Äî Orbes & Nave",
      diff: "MEDIO",
      desc: "Primer uso de nave con orbes.",
      speed: 380,
      gravity: 1700,
      jump: 520,
      length: 5200,
      obstacles: [
        // trigger modo
        { type:"mode", mode:"ship", x: 0 },

        // suelo de pinchos (simulado: muchos spikes separados para ser ligero)
        { type:"spike", x: 220, w:36, h:36 },
        { type:"spike", x: 360, w:36, h:36 },
        { type:"spike", x: 500, w:36, h:36 },
        { type:"spike", x: 640, w:36, h:36 },
        { type:"spike", x: 780, w:36, h:36 },
        { type:"spike", x: 920, w:36, h:36 },

        // bloques + orbes
        { type:"block", x: 700, w:54, h:54 },
        { type:"orb",   x: 720, yOffset:-160 },

        { type:"block", x: 1200, w:54, h:54 },
        { type:"orb",   x: 1220, yOffset:-190 },

        { type:"block", x: 1700, w:54, h:54 },
        { type:"orb",   x: 1720, yOffset:-220 },

        // obst√°culos extra para que se vea movimiento
        { type:"block", x: 2100, w:54, h:140 },
        { type:"block", x: 2400, w:54, h:220, yOffset:-120 },

        // salida de nave
        { type:"mode", mode:"cube", x: 3000 },

        { type:"spike", x: 3250, w:36, h:36 },
        { type:"spike", x: 3480, w:36, h:36 },
        { type:"block", x: 3760, w:54, h:54 },
        { type:"spike", x: 4040, w:36, h:36 },
      ]
    },

    {
      id: "orb-5",
      name: "Nivel 5 ‚Äî Bola & UFO",
      diff: "MEDIO+",
      desc: "Cambios r√°pidos de modo.",
      speed: 400,
      gravity: 1800,
      jump: 540,
      length: 5600,
      obstacles: [
        { type:"mode", mode:"ball", x: 0 },

        { type:"spike", x: 520, w:36, h:36 },
        { type:"spike", x: 780, w:36, h:36 },
        { type:"block", x: 980, w:54, h:54 },
        { type:"platform", x: 1200, w:240, h:22, yOffset:-160 },

        // orbes que ayudan a salir
        { type:"orb", x: 600,  yOffset:-140 },
        { type:"orb", x: 900,  yOffset:-200 },
        { type:"orb", x: 1200, yOffset:-140 },

        // cambio a UFO
        { type:"mode", mode:"ufo", x: 1600 },

        { type:"block", x: 1900, w:54, h:54 },
        { type:"orb", x: 1800, yOffset:-180 },
        { type:"orb", x: 2100, yOffset:-220 },
        { type:"orb", x: 2400, yOffset:-180 },

        { type:"spike", x: 2700, w:36, h:36 },
        { type:"spike", x: 2920, w:36, h:36 },

        // volver a cubo
        { type:"mode", mode:"cube", x: 3200 },

        { type:"block", x: 3600, w:54, h:54 },
        { type:"spike", x: 3920, w:36, h:36 },
        { type:"platform", x: 4200, w:260, h:22, yOffset:-180 },
        { type:"spike", x: 4620, w:36, h:36 },
      ]
    },

    {
      id: "orb-6",
      name: "Nivel 6 ‚Äî Wave",
      diff: "DIF√çCIL",
      desc: "Wave puro con orbes de control.",
      speed: 420,
      gravity: 0,
      jump: 0,
      length: 6000,
      obstacles: [
        { type:"mode", mode:"wave", x: 0 },

        // ‚Äúparedes‚Äù (bloques altos)
        { type:"block", x: 600,  w:40, h:240 },
        { type:"block", x: 600,  w:40, h:240, yOffset:-240 },

        { type:"block", x: 900,  w:40, h:240 },
        { type:"block", x: 900,  w:40, h:240, yOffset:-240 },

        { type:"block", x: 1200,  w:40, h:240 },
        { type:"block", x: 1200,  w:40, h:240, yOffset:-240 },

        // orbes ‚Äúsuaves‚Äù: en wave dan un empuj√≥n vertical peque√±o
        { type:"orb", x: 750,  yOffset:-120 },
        { type:"orb", x: 1050, yOffset:-180 },

        // salida
        { type:"mode", mode:"cube", x: 3500 },

        { type:"spike", x: 3800, w:36, h:36 },
        { type:"block", x: 4100, w:54, h:54 },
        { type:"spike", x: 4400, w:36, h:36 },
      ]
    }
  ];

  // ==========================================================
  //  CANVAS + ESTADO
  // ==========================================================
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const ui = {
    levelName: document.getElementById("uiLevelName"),
    state: document.getElementById("uiState"),
    playerMode: document.getElementById("uiPlayerMode"),
    progress: document.getElementById("uiProgress"),
    attempts: document.getElementById("uiAttempts"),
    speed: document.getElementById("uiSpeed"),
    gravity: document.getElementById("uiGravity"),
    speedBox: document.getElementById("uiSpeedBox"),
    gravBox: document.getElementById("uiGravBox"),
    jumpBox: document.getElementById("uiJumpBox"),
  };

  const speedRange = document.getElementById("speedRange");
  const gravRange  = document.getElementById("gravRange");
  const jumpRange  = document.getElementById("jumpRange");

  const btnMenu    = document.getElementById("btnMenu");
  const btnPause   = document.getElementById("btnPause");
  const btnRestart = document.getElementById("btnRestart");
  const btnPlay    = document.getElementById("btnPlay");

  const levelSelect   = document.getElementById("levelSelect");
  const overlay       = document.getElementById("menuOverlay");
  const levelsGrid    = document.getElementById("levelsGrid");
  const btnCloseMenu  = document.getElementById("btnCloseMenu");
  const btnMenuPlay   = document.getElementById("btnMenuPlay");

  const W = cv.width, H = cv.height;
  const groundY = H - 90;

  // ==========================================================
  //  Estado global
  // ==========================================================
  const state = {
    mode: "MENU", // MENU | PLAYING | PAUSED | WIN | DEAD
    level: null,  // copia del nivel actual (con obstacles)
    attempts: 0,
    camX: 0,
    lastTime: 0,
    // Para triggers "mode" sin repetir:
    nextTriggerIdx: 0,
  };

  // Ajustes runtime (sliders)
  const tuning = {
    speed: 340,
    gravity: 1650,
    jump: 520,
  };

  // ==========================================================
  //  Player + modos
  // ==========================================================
  const PLAYER_MODES = ["cube", "ship", "ball", "ufo", "wave"];

  const player = {
    // coords en pantalla (x fijo, el mundo se mueve con camX)
    x: 160,
    y: groundY - 44,
    w: 44,
    h: 44,

    // f√≠sica
    vy: 0,
    onGround: true,
    alive: true,

    // control
    wantJump: false,   // true si est√° pulsando
    pressedJump: false,// true solo 1 frame cuando "click/keydown"
    canOrb: true,      // para no re-disparar orb en contacto continuo

    // modo
    mode: "cube",
    gravitySign: 1,    // para ball (flip)
  };

  // ==========================================================
  //  Helpers UI
  // ==========================================================
  function setMode(m){
    state.mode = m;

    const map = {
      MENU: ["MEN√ö", "var(--good)"],
      PLAYING: ["JUGANDO", "var(--good)"],
      PAUSED: ["PAUSA", "var(--warn)"],
      WIN: ["VICTORIA", "var(--good)"],
      DEAD: ["KO", "var(--bad)"],
    };

    ui.state.textContent = map[m][0];
    ui.state.style.color = map[m][1];

    ui.playerMode.textContent = (player.mode || "cube").toUpperCase();

    // Sliders bloqueados en men√∫ (pero visibles)
    const isMenu = (m === "MENU");
    speedRange.disabled = isMenu;
    gravRange.disabled  = isMenu;
    jumpRange.disabled  = isMenu;
  }

  function updateKpis(){
    ui.attempts.textContent = state.attempts;
    ui.speed.textContent = Math.round(tuning.speed);
    ui.gravity.textContent = Math.round(tuning.gravity);
    ui.speedBox.textContent = Math.round(tuning.speed);
    ui.gravBox.textContent = Math.round(tuning.gravity);
    ui.jumpBox.textContent = Math.round(tuning.jump);
    ui.playerMode.textContent = (player.mode || "cube").toUpperCase();
  }

  // ==========================================================
  //  Nivel + selecci√≥n
  // ==========================================================
  function setLevelById(id){
    const lvl = LEVELS.find(l => l.id === id) || LEVELS[0];

    // clon seguro (evita mutaciones)
    state.level = structuredClone(lvl);

    // defaults de tuning
    tuning.speed   = lvl.speed;
    tuning.gravity = lvl.gravity;
    tuning.jump    = lvl.jump;

    speedRange.value = tuning.speed;
    gravRange.value  = tuning.gravity;
    jumpRange.value  = tuning.jump;

    ui.levelName.textContent = lvl.name;

    // set modo inicial por triggers (si hay mode en x=0)
    player.mode = "cube";
    player.gravitySign = 1;
    state.nextTriggerIdx = 0;
    applyModeTriggersUpToX(0, true);

    updateKpis();
  }

  function buildLevelSelect(){
    levelSelect.innerHTML = "";
    LEVELS.forEach(l => {
      const opt = document.createElement("option");
      opt.value = l.id;
      opt.textContent = `${l.name} (${l.diff})`;
      levelSelect.appendChild(opt);
    });
  }

  function buildMenuGrid(){
    levelsGrid.innerHTML = "";
    LEVELS.forEach(l => {
      const el = document.createElement("div");
      el.className = "lvl";
      el.dataset.id = l.id;
      el.innerHTML = `
        <h4>${l.name} <span class="tag">${l.diff}</span></h4>
        <div style="color:var(--muted); font-size:13px; line-height:1.35">
          ${l.desc}<br/>
          <span style="opacity:.9">Vel: <b>${l.speed}</b> ¬∑ Grav: <b>${l.gravity}</b> ¬∑ Jump: <b>${l.jump}</b></span>
        </div>
      `;
      el.addEventListener("click", () => {
        levelSelect.value = l.id;
        setLevelById(l.id);
        highlightSelected();
      });
      levelsGrid.appendChild(el);
    });
    highlightSelected();
  }

  function highlightSelected(){
    const id = levelSelect.value;
    [...levelsGrid.children].forEach(c => {
      c.style.outline = (c.dataset.id === id) ? "2px solid #ffffff55" : "none";
    });
  }

  // ==========================================================
  //  Game flow
  // ==========================================================
  function resetRun(){
    state.camX = 0;
    state.nextTriggerIdx = 0;

    player.x = 160;
    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
    player.alive = true;
    player.canOrb = true;

    // modo por triggers iniciales (x=0)
    player.mode = "cube";
    player.gravitySign = 1;
    applyModeTriggersUpToX(0, true);

    setMode("PLAYING");
    updateKpis();
  }

  function startGame(){
    if(!state.level){
      console.warn("No hay nivel seleccionado");
      return;
    }
    state.attempts += 1;
    resetRun();
  }

  function restart(){
    if(!state.level){
      setLevelById(LEVELS[0].id);
    }
    state.attempts += 1;
    resetRun();
  }

  function togglePause(){
    if(state.mode === "PLAYING") setMode("PAUSED");
    else if(state.mode === "PAUSED") setMode("PLAYING");
  }

  function openMenu(){
    overlay.classList.add("show");
    setMode("MENU");
    // En men√∫ NO cambiamos nivel autom√°ticamente: solo UI
  }

  function closeMenu(){
    overlay.classList.remove("show");
    // No forzamos estado aqu√≠, lo maneja startGame/resetRun
  }

  // ==========================================================
  //  Obstacles ‚Üí rects (mundo)
  // ==========================================================
  function obstacleToWorldRect(o){
    const type = o?.type;
    const x = Number(o?.x ?? 0);

    if(type === "platform"){
      const w = Number(o?.w ?? 240);
      const h = Number(o?.h ?? 22);
      const y = groundY + Number(o?.yOffset ?? -120);
      return { type, x, y, w, h };
    }

    if(type === "block"){
      const w = Number(o?.w ?? 54);
      const h = Number(o?.h ?? 54);
      const y = (groundY - h) + Number(o?.yOffset ?? 0);
      return { type, x, y, w, h };
    }

    if(type === "spike"){
      const w = Number(o?.w ?? 36);
      const h = Number(o?.h ?? 36);
      const y = (groundY - h) + Number(o?.yOffset ?? 0);
      return { type, x, y, w, h };
    }

    if(type === "orb"){
      // orb es peque√±o, flotante
      const w = 28, h = 28;
      const y = (groundY - 140) + Number(o?.yOffset ?? 0);
      return { type, x: x, y, w, h };
    }

    // type "mode" no es colisionable
    if(type === "mode"){
      return { type, x, y: 0, w: 0, h: 0 };
    }

    // tipos desconocidos: no rompen nada
    return { type: "unknown", x, y: 0, w: 0, h: 0 };
  }

  function rectsOverlap(a,b){
    return (a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y);
  }

  function kill(){
    player.alive = false;
    setMode("DEAD");
  }

  // ==========================================================
  //  Mode triggers
  // ==========================================================
  function normalizePlayerMode(m){
    const mm = String(m || "").toLowerCase();
    if(PLAYER_MODES.includes(mm)) return mm;
    return "cube";
  }

  function applyModeTriggersUpToX(worldX, forceAll=false){
    if(!state.level) return;

    const obs = state.level.obstacles || [];
    // Ordenamos por x solo una vez si hace falta
    // (clon ya es estable, pero por si el user mete desorden)
    // NOTA: no reordenamos el array para no romper referencias visuales,
    // en su lugar recorremos por √≠ndice y confiamos en orden razonable.
    while(state.nextTriggerIdx < obs.length){
      const o = obs[state.nextTriggerIdx];
      if(o?.type !== "mode"){
        state.nextTriggerIdx++;
        continue;
      }

      const ox = Number(o?.x ?? 0);
      if(!forceAll && ox > worldX) break;

      player.mode = normalizePlayerMode(o?.mode);
      ui.playerMode.textContent = player.mode.toUpperCase();

      // al cambiar modo, reseteos suaves
      if(player.mode === "ball"){
        player.gravitySign = 1;
        player.vy = 0;
      }
      if(player.mode === "wave"){
        // wave: mantenemos y dentro del ‚Äúcanal‚Äù
        player.vy = 0;
      }
      if(player.mode === "ship"){
        // ship: arranca en medio un poco para que se vea
        player.vy = 0;
      }
      if(player.mode === "ufo"){
        player.vy = 0;
      }
      if(player.mode === "cube"){
        // cube en suelo si viene de otro modo
        // (no forzamos, pero si est√° bajo el suelo lo corregimos)
        if(player.y > groundY - player.h) player.y = groundY - player.h;
      }

      state.nextTriggerIdx++;
    }
  }

  // ==========================================================
  //  Inputs
  // ==========================================================
  function pressJump(){
    player.wantJump = true;
    player.pressedJump = true; // solo este frame
    if(state.mode === "PLAYING"){
      // cube: salto directo
      if(player.mode === "cube"){
        if(player.onGround){
          player.vy = -tuning.jump;
          player.onGround = false;
        }
      }

      // ball: cambia gravedad al pulsar (toggle)
      if(player.mode === "ball"){
        player.gravitySign *= -1;
      }

      // ufo: cada pulsaci√≥n impulsa
      if(player.mode === "ufo"){
        player.vy = -tuning.jump * 0.9;
        player.onGround = false;
      }

      // wave: cambia direcci√≥n con mantener/soltar, aqu√≠ no hacemos nada extra
      // ship: mantener/soltar se eval√∫a en tick
    }
  }

  function releaseJump(){
    player.wantJump = false;
  }

  // ==========================================================
  //  F√≠sica por modo
  // ==========================================================
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function physicsCube(dt){
    // gravedad
    player.prevY = player.y;
    player.vy += tuning.gravity * dt;
    player.y  += player.vy * dt;

    // suelo
    if(player.y >= groundY - player.h){
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }
  }

  function physicsShip(dt){
    // SHIP: gravedad + ‚Äúthrust‚Äù al mantener pulsado
    const thrust = tuning.jump * 3.0;  // empuje
    const g = tuning.gravity;

    player.prevY = player.y;

    // gravedad
    player.vy += g * dt;

    // thrust si mantiene
    if(player.wantJump){
      player.vy -= thrust * dt;
    }

    // l√≠mite para evitar locuras
    player.vy = clamp(player.vy, -900, 900);
    player.y += player.vy * dt;

    // l√≠mites de pantalla (canal)
    const top = 40;
    const bottom = groundY - player.h;
    if(player.y < top){
      player.y = top;
      player.vy = 0;
    }
    if(player.y > bottom){
      player.y = bottom;
      player.vy = 0;
    }

    player.onGround = (player.y >= bottom - 0.5);
  }

  function physicsBall(dt){
    // BALL: gravedad invertible
    const g = tuning.gravity * player.gravitySign;

    player.prevY = player.y;
    player.vy += g * dt;
    player.y  += player.vy * dt;

    // colisiona con ‚Äúsuelo‚Äù y ‚Äútecho‚Äù (techo virtual)
    const bottom = groundY - player.h;
    const top = 60;

    if(player.gravitySign === 1){
      if(player.y >= bottom){
        player.y = bottom;
        player.vy = 0;
        player.onGround = true;
      } else player.onGround = false;
      if(player.y < top){
        player.y = top;
        player.vy = 0;
      }
    } else {
      // gravedad hacia arriba
      if(player.y <= top){
        player.y = top;
        player.vy = 0;
        player.onGround = true;
      } else player.onGround = false;
      if(player.y > bottom){
        player.y = bottom;
        player.vy = 0;
      }
    }
  }

  function physicsUfo(dt){
    // UFO: como cube pero sin suelo estricto, y con impulsos por pulsaci√≥n (ya hechos)
    player.prevY = player.y;
    player.vy += tuning.gravity * dt;
    player.y  += player.vy * dt;

    const top = 50;
    const bottom = groundY - player.h;

    if(player.y < top){
      player.y = top;
      player.vy = 0;
    }
    if(player.y > bottom){
      player.y = bottom;
      player.vy = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }
  }

  function physicsWave(dt){
    // WAVE: se mueve en diagonal, control = mantener para subir
    // vertical speed proporcional a la velocidad del nivel
    const v = tuning.speed * 0.95;
    const dir = player.wantJump ? -1 : 1; // mantener sube, soltar baja
    player.prevY = player.y;
    player.vy = dir * v;
    player.y += player.vy * dt;

    const top = 60;
    const bottom = groundY - player.h;
    if(player.y < top) player.y = top;
    if(player.y > bottom) player.y = bottom;

    player.onGround = (player.y >= bottom - 0.5);
  }

  function runPhysics(dt){
    if(player.mode === "cube") return physicsCube(dt);
    if(player.mode === "ship") return physicsShip(dt);
    if(player.mode === "ball") return physicsBall(dt);
    if(player.mode === "ufo")  return physicsUfo(dt);
    if(player.mode === "wave") return physicsWave(dt);
    // fallback
    return physicsCube(dt);
  }

  // ==========================================================
  //  Colisiones (dependen del modo)
  // ==========================================================
  function worldPlayerRect(){
    // jugador en mundo = x fijo en pantalla + camX
    return { x: player.x + state.camX, y: player.y, w: player.w, h: player.h };
  }

  function handleOrbs(pWorld){
    if(!state.level) return;
    for(const o of state.level.obstacles){
      if(o?.type !== "orb") continue;
      const r = obstacleToWorldRect(o);

      // cerca de c√°mara
      if(r.x < state.camX - 200 || r.x > state.camX + W + 300) continue;

      const hit = rectsOverlap(pWorld, r);

      if(hit){
        // requiere ‚Äúpulsaci√≥n‚Äù (pressedJump) o mantener (wantJump) seg√∫n modo
        const wants = (player.pressedJump || player.wantJump);

        if(wants && player.canOrb){
          // efecto orb por modo
          if(player.mode === "cube" || player.mode === "ufo"){
            player.vy = -tuning.jump * 1.1;
            player.onGround = false;
          } else if(player.mode === "ship"){
            // orb en ship = peque√±o empuj√≥n hacia arriba
            player.vy -= tuning.jump * 0.35;
          } else if(player.mode === "ball"){
            // orb en ball = flip + boost
            player.gravitySign *= -1;
            player.vy = -tuning.jump * 0.45 * player.gravitySign;
          } else if(player.mode === "wave"){
            // orb en wave = micro ajuste
            player.y -= 22;
          }
          player.canOrb = false;
        }
      } else {
        player.canOrb = true;
      }
    }
  }

  function handleSolidCollisions(pWorld){
    if(!state.level) return;

    for(const o of state.level.obstacles){
      if(!o || !o.type) continue;

      // ignorar triggers
      if(o.type === "mode" || o.type === "orb") continue;

      const r = obstacleToWorldRect(o);

      // frustum
      if(r.x + r.w < state.camX - 200) continue;
      if(r.x > state.camX + W + 300) continue;

      // SPIKE: muerte si toca ‚Äúzona peligrosa‚Äù
      if(r.type === "spike"){
        // cube/ball/ufo: si overlap => muerte
        // ship/wave: tambi√©n
        if(rectsOverlap(pWorld, r)){
          kill();
          return;
        }
        continue;
      }

      // PLATFORM: solo ‚Äúpisable‚Äù (para cube/ball/ufo)
      if(r.type === "platform"){
        if(player.mode === "ship" || player.mode === "wave"){
          // en estos modos, plataforma es obst√°culo s√≥lido
          if(rectsOverlap(pWorld, r)){ kill(); return; }
          continue;
        }

        const above = (player.prevY + player.h) <= (r.y + 18);
        const willTouch = rectsOverlap(pWorld, r);
        if(above && willTouch && player.vy > 0){
          player.y = r.y - player.h;
          player.vy = 0;
          player.onGround = true;
        }
        continue;
      }

      // BLOCK: s√≥lido. En cube/ball/ufo permite caer encima, lateral mata.
      if(r.type === "block"){
        const overlap = rectsOverlap(pWorld, r);

        if(player.mode === "ship" || player.mode === "wave"){
          if(overlap){ kill(); return; }
          continue;
        }

        const prevBottom = player.prevY + player.h;
        const currBottom = player.y + player.h;

        const fallingFromAbove =
          prevBottom <= r.y &&
          currBottom >= r.y &&
          player.vy > 0 &&
          pWorld.x + pWorld.w > r.x &&
          pWorld.x < r.x + r.w;

        if(fallingFromAbove){
          player.y = r.y - player.h;
          player.vy = 0;
          player.onGround = true;
        } else if(overlap){
          kill();
          return;
        }
      }
    }
  }

  // ==========================================================
  //  Render
  // ==========================================================
  function drawBackground(){
    ctx.fillStyle = "#050818";
    ctx.fillRect(0,0,W,H);

    const g = ctx.createRadialGradient(W*0.25, H*0.2, 40, W*0.25, H*0.2, 520);
    g.addColorStop(0, "#2b5cff22");
    g.addColorStop(1, "#0000");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "#ffffff10";
    for(let i=0;i<120;i++){
      const x = (i*97)%W;
      const y = (i*53)%H;
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function drawGround(){
    ctx.fillStyle = "#0b1634";
    ctx.fillRect(0, groundY, W, H-groundY);

    ctx.strokeStyle = "#ffffff22";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(W, groundY);
    ctx.stroke();

    ctx.fillStyle = "#ffffff0f";
    const size = 24;
    for(let x=0; x<W; x+=size){
      ctx.fillRect(x, groundY + (x/size%2===0?12:0), size-2, 10);
    }
  }

  function drawObstacle(o){
    const r = obstacleToWorldRect(o);
    if(r.type === "unknown" || r.type === "mode") return;

    const sx = r.x - state.camX;
    const sy = r.y;

    if(r.type === "block"){
      ctx.fillStyle = "#2a4fff55";
      ctx.fillRect(sx, sy, r.w, r.h);
      ctx.strokeStyle = "#93c5ff66";
      ctx.lineWidth = 2;
      ctx.strokeRect(sx+1, sy+1, r.w-2, r.h-2);
      ctx.fillStyle = "#ffffff18";
      ctx.fillRect(sx+4, sy+4, r.w-8, 8);
    }
    else if(r.type === "spike"){
      ctx.fillStyle = "#ff5b6eaa";
      ctx.strokeStyle = "#ffd1d7aa";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sx, sy+r.h);
      ctx.lineTo(sx+r.w/2, sy);
      ctx.lineTo(sx+r.w, sy+r.h);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    else if(r.type === "platform"){
      ctx.fillStyle = "#38d39f44";
      ctx.fillRect(sx, sy, r.w, r.h);
      ctx.strokeStyle = "#38d39f99";
      ctx.lineWidth = 2;
      ctx.strokeRect(sx+1, sy+1, r.w-2, r.h-2);
    }
    else if(r.type === "orb"){
      // orb: c√≠rculo brillante
      const cx = sx + r.w/2;
      const cy = sy + r.h/2;
      const rad = r.w/2;

      const gg = ctx.createRadialGradient(cx, cy, 2, cx, cy, rad+8);
      gg.addColorStop(0, "#ffffffcc");
      gg.addColorStop(0.25, "#38d39fcc");
      gg.addColorStop(1, "#38d39f11");
      ctx.fillStyle = gg;
      ctx.beginPath();
      ctx.arc(cx, cy, rad+6, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#38d39fbb";
      ctx.beginPath();
      ctx.arc(cx, cy, rad, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = "#ffffff88";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, rad, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawPlayer(){
    const px = player.x;
    const py = player.y;

    // color por modo
    let fill = "#e9f0ff";
    if(player.mode === "ship") fill = "#c7ffe9";
    if(player.mode === "ball") fill = "#ffe9b8";
    if(player.mode === "ufo")  fill = "#d9c6ff";
    if(player.mode === "wave") fill = "#bfe0ff";

    // forma por modo (simple)
    ctx.fillStyle = fill;

    if(player.mode === "ship"){
      // tri√°ngulo nave
      ctx.beginPath();
      ctx.moveTo(px, py + player.h*0.5);
      ctx.lineTo(px + player.w, py);
      ctx.lineTo(px + player.w, py + player.h);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#00000055";
      ctx.lineWidth = 2;
      ctx.stroke();
      return;
    }

    if(player.mode === "ball"){
      const cx = px + player.w/2;
      const cy = py + player.h/2;
      ctx.beginPath();
      ctx.arc(cx, cy, player.w/2, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "#00000055";
      ctx.lineWidth = 2;
      ctx.stroke();
      return;
    }

    if(player.mode === "wave"){
      // rombo
      const cx = px + player.w/2;
      const cy = py + player.h/2;
      ctx.beginPath();
      ctx.moveTo(cx, py);
      ctx.lineTo(px + player.w, cy);
      ctx.lineTo(cx, py + player.h);
      ctx.lineTo(px, cy);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#00000055";
      ctx.lineWidth = 2;
      ctx.stroke();
      return;
    }

    // cube / ufo (cuadro)
    ctx.fillRect(px, py, player.w, player.h);
    ctx.strokeStyle = "#00000055";
    ctx.lineWidth = 2;
    ctx.strokeRect(px+1, py+1, player.w-2, player.h-2);

    // ‚Äúcara‚Äù en cube
    if(player.mode === "cube"){
      ctx.fillStyle = "#0b1634";
      ctx.fillRect(px+12, py+14, 6, 6);
      ctx.fillRect(px+26, py+14, 6, 6);
      ctx.fillRect(px+16, py+28, 12, 4);
    }
  }

  function drawHUD(){
    if(!state.level) return;

    const prog = Math.max(0, Math.min(1, state.camX / state.level.length));
    ui.progress.textContent = Math.round(prog*100) + "%";

    const barW = W - 40, barH = 10, x = 20, y = 18;
    ctx.fillStyle = "#ffffff14";
    ctx.fillRect(x, y, barW, barH);
    ctx.fillStyle = "#38d39fbb";
    ctx.fillRect(x, y, barW*prog, barH);
    ctx.strokeStyle = "#ffffff22";
    ctx.strokeRect(x, y, barW, barH);

    if(state.mode === "MENU"){
      ctx.fillStyle = "#ffffffcc";
      ctx.font = "900 28px system-ui";
      ctx.fillText("Pulsa JUGAR o abre MEN√ö (M)", 22, 72);
      ctx.fillStyle = "#b9c8ffcc";
      ctx.font = "600 14px system-ui";
      ctx.fillText("Objetivo: sobrevivir. Los orbes ayudan. Los modos cambian el control.", 22, 96);
    }
    if(state.mode === "PAUSED"){
      ctx.fillStyle = "#ffffffdd";
      ctx.font = "900 36px system-ui";
      ctx.fillText("PAUSA", 22, 80);
    }
    if(state.mode === "DEAD"){
      ctx.fillStyle = "#ffccd3";
      ctx.font = "900 34px system-ui";
      ctx.fillText("¬°KO! Pulsa R para reiniciar", 22, 80);
    }
    if(state.mode === "WIN"){
      ctx.fillStyle = "#c7ffe9";
      ctx.font = "900 34px system-ui";
      ctx.fillText("¬°VICTORIA! üéâ Pulsa M para otro nivel", 22, 80);
    }
  }

  // ==========================================================
  //  Loop
  // ==========================================================
  function tick(ts){
    if(!state.lastTime) state.lastTime = ts;
    const dt = Math.min(0.033, (ts - state.lastTime) / 1000);
    state.lastTime = ts;

    // UPDATE
    if(state.mode === "PLAYING" && state.level && player.alive){
      // c√°mara avanza siempre
      state.camX += tuning.speed * dt;

      // triggers de modo
      applyModeTriggersUpToX(state.camX + player.x + 10, false);

      // f√≠sica por modo
      runPhysics(dt);

      // orbes
      const pWorld = worldPlayerRect();
      handleOrbs(pWorld);

      // colisiones s√≥lidas
      handleSolidCollisions(pWorld);

      // win
      if(state.camX >= state.level.length){
        setMode("WIN");
      }
    }

    // RENDER
    drawBackground();
    drawGround();

    if(state.level){
      const viewL = state.camX - 200;
      const viewR = state.camX + W + 300;

      for(const o of state.level.obstacles){
        const ox = Number(o?.x ?? 0);
        const ow = Number(o?.w ?? 0);
        if(ox + ow < viewL) continue;
        if(ox > viewR) continue;
        drawObstacle(o);
      }
    }

    drawPlayer();
    drawHUD();

    // reset ‚ÄúpressedJump‚Äù tras un frame
    player.pressedJump = false;

    requestAnimationFrame(tick);
  }

  // ==========================================================
  //  Eventos teclado / touch
  // ==========================================================
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(k === " " || k === "arrowup") { e.preventDefault(); pressJump(); }
    if(k === "p") togglePause();
    if(k === "r") restart();
    if(k === "m") openMenu();
  });

  window.addEventListener("keyup", (e) => {
    const k = e.key.toLowerCase();
    if(k === " " || k === "arrowup") { e.preventDefault(); releaseJump(); }
  });

  cv.addEventListener("pointerdown", () => pressJump());
  window.addEventListener("pointerup", () => releaseJump());

  // Buttons
  btnMenu.addEventListener("click", openMenu);
  btnCloseMenu.addEventListener("click", closeMenu);
  btnPause.addEventListener("click", togglePause);
  btnRestart.addEventListener("click", restart);

  btnPlay.addEventListener("click", () => {
    closeMenu();
    // asegurar nivel seleccionado
    if(!state.level) setLevelById(levelSelect.value || LEVELS[0].id);
    startGame();
  });

  btnMenuPlay.addEventListener("click", () => {
    closeMenu();
    // asegura nivel actual del select
    setLevelById(levelSelect.value || LEVELS[0].id);
    startGame();
  });

  // Sliders
  speedRange.addEventListener("input", () => {
    tuning.speed = Number(speedRange.value);
    updateKpis();
  });
  gravRange.addEventListener("input", () => {
    tuning.gravity = Number(gravRange.value);
    updateKpis();
  });
  jumpRange.addEventListener("input", () => {
    tuning.jump = Number(jumpRange.value);
    updateKpis();
  });

  // Selector
  levelSelect.addEventListener("change", () => {
    setLevelById(levelSelect.value);
    highlightSelected();
  });

  // ==========================================================
  //  Init
  // ==========================================================
  buildLevelSelect();
  buildMenuGrid();

  levelSelect.value = LEVELS[0].id;
  setLevelById(LEVELS[0].id);

  setMode("MENU");
  updateKpis();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
