<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dash Pro ‚Äî Niveles + Men√∫ (HTML)</title>
  <style>
    :root { --bg:#0b1020; --fg:#eaf0ff; --muted:#9fb0d0; --acc:#7cf7c7; --danger:#ff5a7a; --panel:rgba(0,0,0,.35); }
    *{ box-sizing:border-box; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    body{ margin:0; color:var(--fg); background:radial-gradient(1200px 600px at 50% 0%, #15234a 0%, var(--bg) 55%, #050816 100%); }
    .wrap{ max-width:980px; margin:0 auto; padding:16px; }
    header{ display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:10px; }
    h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .hint{ color:var(--muted); font-size:13px; margin-top:6px; }
    canvas{
      width:100%;
      height:auto;
      aspect-ratio:16/9;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(#0b1330, #070a18);
      display:block;
      margin-top:14px;
      box-shadow:0 20px 80px rgba(0,0,0,.45);
      touch-action:manipulation;
    }
    .hud{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:10px 12px; border:1px solid rgba(255,255,255,.12);
      border-radius:12px; background:rgba(0,0,0,.25); margin-top:10px;
      justify-content:space-between;
    }
    .hud .left, .hud .right{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .hud b{ color:var(--acc); }
    button{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--fg);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
    }
    button:hover{ background: rgba(255,255,255,.10); }
    button:active{ transform:translateY(1px); }
    .kbd{ padding:2px 8px; border:1px solid rgba(255,255,255,.18); border-bottom-width:3px; border-radius:8px; background:rgba(255,255,255,.06); }
    .panel{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:14px;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap:12px;
      margin-top:12px;
    }
    .card{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
    }
    .card h3{ margin:0 0 6px 0; font-size:15px; }
    .card p{ margin:0; color:var(--muted); font-size:12px; line-height:1.35; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .tiny{ font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Dash Pro ‚Äî Men√∫ + Niveles</h1>
      <div class="hint">
        Saltar: <span class="kbd">Espacio</span> / <span class="kbd">‚Üë</span> / toque.
        Reiniciar: <span class="kbd">R</span>. Pausa: <span class="kbd">P</span>.
      </div>
    </div>
    <div class="row">
      <button id="btnMenu">üè† Men√∫</button>
      <button id="btnPause">‚è∏Ô∏è Pausa</button>
      <button id="btnRestart">üîÑ Reiniciar</button>
      <button id="btnMute">üîä Sonido: ON</button>
    </div>
  </header>

  <div class="hud" id="hud">
    <div class="left">
      <div>Nivel: <b id="lvlName">‚Äî</b></div>
      <div>Progreso: <b id="progress">0%</b></div>
      <div>Intentos: <b id="attempts">0</b></div>
    </div>
    <div class="right">
      <div>Estado: <b id="state">MEN√ö</b></div>
      <div>FPS: <b id="fps">‚Äî</b></div>
    </div>
  </div>

  <canvas id="game" width="960" height="540"></canvas>

  <div id="menu" class="panel" style="margin-top:12px;">
    <div style="display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:flex-end;">
      <div>
        <div style="font-weight:800; font-size:18px;">Selecciona un nivel</div>
        <div class="tiny">Niveles dise√±ados para ser jugables. Si quieres, luego creamos editor.</div>
      </div>
      <div class="tiny">Tip: si ‚Äúno salta‚Äù, es porque estabas en el aire. Aqu√≠ no hay doble salto (modo cl√°sico).</div>
    </div>

    <div class="grid" id="levelGrid"></div>

    <div class="row" style="margin-top:12px;">
      <button id="btnPlay">‚ñ∂Ô∏è Jugar nivel</button>
      <button id="btnHow">‚ùì Controles</button>
    </div>
    <div class="tiny" id="menuInfo" style="margin-top:8px;"></div>
  </div>
</div>

<script>
(() => {
  // ====== Canvas ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  const groundY = Math.floor(H * 0.78);

  // ====== UI ======
  const $lvlName = document.getElementById("lvlName");
  const $progress = document.getElementById("progress");
  const $attempts = document.getElementById("attempts");
  const $state = document.getElementById("state");
  const $fps = document.getElementById("fps");

  const btnMenu = document.getElementById("btnMenu");
  const btnPause = document.getElementById("btnPause");
  const btnRestart = document.getElementById("btnRestart");
  const btnMute = document.getElementById("btnMute");

  const menuEl = document.getElementById("menu");
  const gridEl = document.getElementById("levelGrid");
  const btnPlay = document.getElementById("btnPlay");
  const btnHow = document.getElementById("btnHow");
  const menuInfo = document.getElementById("menuInfo");

  // ====== Audio (beeps) ======
  let audioCtx = null;
  let muted = false;
  function beep(freq=440, dur=0.06, type="sine", gain=0.03) {
    if (muted) return;
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime + dur);
    } catch {}
  }
  function winSound(){ beep(740,0.07,"triangle",0.02); beep(932,0.07,"triangle",0.02); beep(1175,0.09,"triangle",0.02); }
  function dieSound(){ beep(220,0.12,"sawtooth",0.03); beep(170,0.16,"sawtooth",0.03); }

  // ====== Game state ======
  let mode = "menu"; // menu | playing | paused | gameover | win
  let attempts = 0;
  let levelIndex = 0;

  // Fixed timestep (reduce ‚Äúva mal‚Äù)
  const FIXED_DT = 1/120; // 120 Hz physics
  let accumulator = 0;
  let lastT = performance.now();

  // FPS estimate
  let fpsAcc = 0, fpsCount = 0, fpsLast = performance.now();

  // ====== Player ======
  const player = {
    x: Math.floor(W * 0.22),
    y: groundY,
    size: 36,
    vy: 0,
    onGround: true,
    rot: 0
  };

  // Jump feels: buffer + coyote time (cero delay)
  const jump = {
    gravity: 1700,
    jumpVel: -650,
    // buffer: si pulsas un poco antes de tocar suelo, salta igualmente
    bufferTime: 0.12,
    buffer: 0,
    // coyote: si sales del suelo, a√∫n puedes saltar un pel√≠n
    coyoteTime: 0.10,
    coyote: 0
  };

  // ====== Level format ======
  // We'll use an array of "segments" placed along X.
  // Each obstacle: {type:'spike'|'block', x, w, h}
  // All obstacles sit on ground (for now) like classic beginner GD.
  const levels = [
    {
      name: "Nivel 1 ‚Äî F√°cil",
      desc: "Aprende ritmo b√°sico. Espacios amplios, nada imposible.",
      speed: 340,
      length: 2600,
      obstacles: [
        // x, type, size
        {type:"spike", x: 420, w:36, h:36},
        {type:"spike", x: 700, w:36, h:36},
        {type:"block", x: 960, w:54, h:54},
        {type:"spike", x: 1150, w:36, h:36},
        {type:"spike", x: 1350, w:36, h:36},
        {type:"block", x: 1600, w:54, h:54},
        {type:"spike", x: 1780, w:36, h:36},
        {type:"spike", x: 1950, w:36, h:36},
        {type:"block", x: 2180, w:54, h:54},
        {type:"spike", x: 2360, w:36, h:36},
      ]
    },
    {
      name: "Nivel 2 ‚Äî Medio",
      desc: "M√°s ritmo. Doble pincho y bloques m√°s seguidos, pero jugable.",
      speed: 340,
      length: 3200,
      obstacles: [
        {type:"spike", x: 420, w:36, h:36},
        {type:"spike", x: 600, w:36, h:36},
        {type:"block", x: 820, w:54, h:54},
        {type:"spike", x: 1040, w:36, h:36},
        {type:"spike", x: 1100, w:36, h:36},
        {type:"block", x: 1320, w:54, h:54},
        {type:"block", x: 1460, w:54, h:54},
        {type:"spike", x: 1660, w:36, h:36},
        {type:"spike", x: 1860, w:36, h:36},
        {type:"spike", x: 1920, w:36, h:36},
        {type:"block", x: 2120, w:54, h:54},
        {type:"spike", x: 2320, w:36, h:36},
        {type:"block", x: 2520, w:54, h:54},
        {type:"spike", x: 2720, w:36, h:36},
        {type:"spike", x: 2780, w:36, h:36},
        {type:"block", x: 2940, w:54, h:54},
      ]
    },
    {
      name: "Nivel 3 ‚Äî Dif√≠cil (justo)",
      desc: "Ritmo r√°pido. Requiere timing, pero sin saltos imposibles.",
      speed:360,
      length: 3800,
      obstacles: [
        {type:"spike", x: 420, w:36, h:36},
        {type:"block", x: 620, w:54, h:54},
        {type:"spike", x: 820, w:36, h:36},
        {type:"spike", x: 880, w:36, h:36},
        {type:"block", x: 1040, w:54, h:54},
        {type:"block", x: 1180, w:54, h:54},
        {type:"spike", x: 1400, w:36, h:36},
        {type:"spike", x: 1460, w:36, h:36},
        {type:"spike", x: 1520, w:36, h:36},
        {type:"block", x: 1700, w:54, h:54},
        {type:"spike", x: 1900, w:36, h:36},
        {type:"block", x: 2060, w:54, h:54},
        {type:"spike", x: 2260, w:36, h:36},
        {type:"spike", x: 2320, w:36, h:36},
        {type:"block", x: 2500, w:54, h:54},
        {type:"block", x: 2640, w:54, h:54},
        {type:"spike", x: 2860, w:36, h:36},
        {type:"spike", x: 2920, w:36, h:36},
        {type:"spike", x: 2980, w:36, h:36},
        {type:"block", x: 3200, w:54, h:54},
        {type:"spike", x: 3420, w:36, h:36},
      ]
    }
  ];

  // Convert obstacles to world coordinates and store "scrollX"
  let scrollX = 0;

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function setMode(m){
    mode = m;
    if (m === "menu"){
      menuEl.style.display = "block";
      $state.textContent = "MEN√ö";
      btnPause.textContent = "‚è∏Ô∏è Pausa";
    } else {
      menuEl.style.display = "none";
    }
    if (m === "paused") $state.textContent = "PAUSA";
    if (m === "playing") $state.textContent = "JUGANDO";
    if (m === "gameover") $state.textContent = "GAME OVER";
    if (m === "win") $state.textContent = "VICTORIA";
  }

  function loadLevel(i){
    levelIndex = clamp(i, 0, levels.length-1);
    const L = levels[levelIndex];
    $lvlName.textContent = L.name;
    menuInfo.textContent = L.desc + `  ¬∑ Velocidad: ${L.speed} ¬∑ Longitud: ${L.length}`;
    drawMenuSelection();
  }

  function resetRun(){
    const L = levels[levelIndex];
    scrollX = 0;
    player.y = groundY;
    player.vy = 0;
    player.onGround = true;
    player.rot = 0;
    jump.buffer = 0;
    jump.coyote = jump.coyoteTime;
    $progress.textContent = "0%";
  }

  function startRun(){
    attempts++;
    $attempts.textContent = String(attempts);
    resetRun();
    setMode("playing");
    beep(880, 0.06, "triangle", 0.02);
  }

  function die(){
    setMode("gameover");
    dieSound();
  }

  function win(){
    setMode("win");
    winSound();
  }

  // ====== Rendering ======
  const stars = Array.from({length: 90}, () => ({
    x: Math.random() * W,
    y: Math.random() * (H * 0.6),
    r: Math.random() * 1.6 + 0.2,
    s: Math.random() * 26 + 8
  }));

  function drawBackground(dt){
    ctx.fillStyle = "#070a18";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(234,240,255,0.8)";
    for (const st of stars){
      st.x -= st.s * dt;
      if (st.x < -5) st.x = W + Math.random() * 40;
      ctx.beginPath();
      ctx.arc(st.x, st.y, st.r, 0, Math.PI*2);
      ctx.fill();
    }
    const grd = ctx.createLinearGradient(0, groundY - 160, 0, groundY + 160);
    grd.addColorStop(0, "rgba(124,247,199,0.12)");
    grd.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grd;
    ctx.fillRect(0, groundY - 180, W, 360);

    // Ground line
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY + 1);
    ctx.lineTo(W, groundY + 1);
    ctx.stroke();

    // Ground tiles
    const tileW = 46;
    const L = levels[levelIndex];
    const move = (scrollX * 0.35) % tileW;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    for (let x = -tileW; x < W + tileW; x += tileW){
      const xx = x - move;
      ctx.fillRect(xx, groundY + 6, tileW - 6, 10);
    }
  }

  function drawPlayer(){
    ctx.save();
    ctx.translate(player.x + player.size/2, player.y - player.size/2);
    ctx.rotate(player.rot);
    ctx.fillStyle = "#7cf7c7";
    ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(-player.size/2 + 7, -player.size/2 + 9, 10, 10);
    ctx.fillRect(-player.size/2 + 21, -player.size/2 + 9, 10, 10);
    ctx.fillRect(-player.size/2 + 10, -player.size/2 + 26, 18, 6);
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size);
    ctx.restore();
  }

  function drawSpike(x, w, h){
    ctx.save();
    ctx.translate(x, groundY);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(w/2, -h);
    ctx.lineTo(w,0);
    ctx.closePath();
    ctx.fillStyle = "#ff5a7a";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }

  function drawBlock(x, w, h){
    ctx.save();
    ctx.translate(x, groundY);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(0, -h, w, h);
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, -h, w, h);
    ctx.restore();
  }

  function drawOverlay(){
    if (mode === "playing") return;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,W,H);
    ctx.textAlign = "center";

    if (mode === "menu"){
      ctx.fillStyle = "rgba(234,240,255,0.92)";
      ctx.font = "800 40px system-ui";
      ctx.fillText("MEN√ö", W/2, H/2 - 20);
      ctx.font = "500 18px system-ui";
      ctx.fillStyle = "rgba(234,240,255,0.78)";
      ctx.fillText("Elige nivel abajo y pulsa Jugar", W/2, H/2 + 20);
      return;
    }

    if (mode === "paused"){
      ctx.fillStyle = "rgba(234,240,255,0.92)";
      ctx.font = "800 40px system-ui";
      ctx.fillText("PAUSA", W/2, H/2 - 20);
      ctx.font = "500 18px system-ui";
      ctx.fillStyle = "rgba(234,240,255,0.78)";
      ctx.fillText("Pulsa P para continuar", W/2, H/2 + 20);
      return;
    }

    if (mode === "gameover"){
      ctx.fillStyle = "rgba(234,240,255,0.92)";
      ctx.font = "900 44px system-ui";
      ctx.fillText("GAME OVER", W/2, H/2 - 22);
      ctx.font = "600 18px system-ui";
      ctx.fillStyle = "rgba(234,240,255,0.80)";
      ctx.fillText("Pulsa ESPACIO / ‚Üë / toque para reintentar", W/2, H/2 + 20);
      ctx.fillText("Pulsa R para reiniciar / Men√∫ para cambiar nivel", W/2, H/2 + 48);
      return;
    }

    if (mode === "win"){
      ctx.fillStyle = "rgba(234,240,255,0.92)";
      ctx.font = "900 44px system-ui";
      ctx.fillText("¬°VICTORIA!", W/2, H/2 - 22);
      ctx.font = "600 18px system-ui";
      ctx.fillStyle = "rgba(234,240,255,0.80)";
      ctx.fillText("Pulsa ESPACIO / ‚Üë / toque para jugar otra vez", W/2, H/2 + 20);
      ctx.fillText("Pulsa Men√∫ para cambiar de nivel", W/2, H/2 + 48);
      return;
    }
  }

  // ====== Collision ======
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // Player rect: top-left in canvas coordinates
  function playerRect(){
    return {
      x: player.x,
      y: player.y - player.size,
      w: player.size,
      h: player.size
    };
  }

  function obstacleRectsOnScreen(){
    const L = levels[levelIndex];
    const res = [];
    for (const o of L.obstacles){
      const sx = o.x - scrollX; // screen x
      if (sx < -120 || sx > W + 120) continue;
      if (o.type === "block"){
        res.push({type:"block", x:sx, y:groundY - o.h, w:o.w, h:o.h});
      } else {
        // spike: approximate as a box for collision (fair)
        res.push({type:"spike", x:sx, y:groundY - o.h, w:o.w, h:o.h});
      }
    }
    return res;
  }

  // ====== Input (no delay) ======
  function requestJump(){
    if (mode === "menu"){ startRun(); return; }
    if (mode === "paused"){ return; }
    if (mode === "gameover" || mode === "win"){ startRun(); return; }
    // playing
    jump.buffer = jump.bufferTime; // buffer jump press
  }

  // ====== Update ======
  function update(dt){
    if (mode !== "playing") return;

    const L = levels[levelIndex];

    // progress
    const pct = clamp((scrollX / L.length) * 100, 0, 100);
    $progress.textContent = `${pct.toFixed(0)}%`;

    // scroll
    scrollX += L.speed * dt;

    // finish
    if (scrollX >= L.length){
      win();
      return;
    }

    // timers
    jump.buffer = Math.max(0, jump.buffer - dt);
    jump.coyote = Math.max(0, jump.coyote - dt);

    // gravity
    player.vy += jump.gravity * dt;
    player.y += player.vy * dt;

    // ground collision
    if (player.y >= groundY){
      player.y = groundY;
      player.vy = 0;
      if (!player.onGround) beep(520, 0.02, "sine", 0.01);
      player.onGround = true;
      player.rot = 0;
      jump.coyote = jump.coyoteTime;
    } else {
      if (player.onGround) jump.coyote = jump.coyoteTime; // just left (safe)
      player.onGround = false;
      player.rot += (Math.PI * 2) * dt * 1.2;
    }

    // Execute buffered jump if allowed (coyote or onGround)
    if (jump.buffer > 0 && (player.onGround || jump.coyote > 0)){
      player.vy = jump.jumpVel;
      player.onGround = false;
      jump.buffer = 0;
      jump.coyote = 0;
      beep(740, 0.04, "square", 0.02);
    }

    // Collision with obstacles (screen rects)
    const p = playerRect();
    const obs = obstacleRectsOnScreen();

    // Also allow landing on blocks (simple platform-like)
    for (const o of obs){
      if (o.type !== "block") continue;
      // If player is falling and hits top of block, land
      const wasAbove = (p.y + p.h) <= (o.y + 10);
      const nowOver = rectsOverlap(p.x, p.y, p.w, p.h, o.x, o.y, o.w, o.h);
      if (nowOver && player.vy >= 0 && wasAbove){
        player.y = o.y; // top of block is player's groundY
        player.vy = 0;
        player.onGround = true;
        player.rot = 0;
        jump.coyote = jump.coyoteTime;
      }
    }

    // Recompute after potential landing on blocks
    const p2 = playerRect();
    for (const o of obs){
      // block collision (side) or spike collision -> die
      if (rectsOverlap(p2.x, p2.y, p2.w, p2.h, o.x, o.y, o.w, o.h)){
        die();
        return;
      }
    }
  }

  function render(dt){
    drawBackground(dt);

    // Draw obstacles
    const L = levels[levelIndex];
    for (const o of L.obstacles){
      const sx = o.x - scrollX;
      if (sx < -160 || sx > W + 160) continue;
      if (o.type === "block") drawBlock(sx, o.w, o.h);
      else drawSpike(sx, o.w, o.h);
    }

    drawPlayer();
    drawOverlay();
  }

  function loop(t){
    const frameDt = Math.min(0.05, (t - lastT) / 1000);
    lastT = t;

    // FPS
    fpsAcc += frameDt; fpsCount++;
    if (t - fpsLast > 500){
      const fps = Math.round(fpsCount / fpsAcc);
      $fps.textContent = String(fps);
      fpsAcc = 0; fpsCount = 0; fpsLast = t;
    }

    // Update with fixed dt
    if (mode === "playing"){
      accumulator += frameDt;
      // avoid spiral of death
      accumulator = Math.min(accumulator, 0.25);

      while (accumulator >= FIXED_DT){
        update(FIXED_DT);
        accumulator -= FIXED_DT;
        if (mode !== "playing") break;
      }
    }

    render(frameDt);
    requestAnimationFrame(loop);
  }

  // ====== Menu / level grid ======
  function drawMenuSelection(){
    gridEl.innerHTML = "";
    levels.forEach((lv, idx) => {
      const card = document.createElement("div");
      card.className = "card";
      card.style.outline = idx === levelIndex ? "2px solid rgba(124,247,199,0.55)" : "none";
      card.innerHTML = `
        <h3>${lv.name}</h3>
        <p>${lv.desc}</p>
        <p style="margin-top:8px;" class="tiny">Velocidad: <b style="color:var(--acc)">${lv.speed}</b> ¬∑ Longitud: <b style="color:var(--acc)">${lv.length}</b></p>
        <div class="row" style="margin-top:10px;">
          <button data-pick="${idx}">Elegir</button>
        </div>
      `;
      gridEl.appendChild(card);
    });

    gridEl.querySelectorAll("button[data-pick]").forEach(btn => {
      btn.addEventListener("click", () => {
        loadLevel(Number(btn.getAttribute("data-pick")));
      });
    });
  }

  // ====== Controls ======
  function togglePause(){
    if (mode === "playing"){
      setMode("paused");
      btnPause.textContent = "‚ñ∂Ô∏è Continuar";
    } else if (mode === "paused"){
      setMode("playing");
      btnPause.textContent = "‚è∏Ô∏è Pausa";
    }
  }

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "ArrowUp"){
      e.preventDefault();
      requestJump();
    }
    if (e.code === "KeyR"){
      e.preventDefault();
      if (mode === "playing" || mode === "paused" || mode === "gameover" || mode === "win"){
        startRun();
      }
    }
    if (e.code === "KeyP"){
      e.preventDefault();
      if (mode === "playing" || mode === "paused") togglePause();
    }
    if (e.code === "Escape"){
      e.preventDefault();
      setMode("menu");
    }
  }, {passive:false});

  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    requestJump();
  }, {passive:false});

  // Buttons
  btnMenu.addEventListener("click", () => setMode("menu"));
  btnPause.addEventListener("click", () => { if (mode==="playing"||mode==="paused") togglePause(); });
  btnRestart.addEventListener("click", () => startRun());
  btnMute.addEventListener("click", () => {
    muted = !muted;
    btnMute.textContent = muted ? "üîá Sonido: OFF" : "üîä Sonido: ON";
    if (!muted) beep(880, 0.06, "triangle", 0.02);
  });

  btnPlay.addEventListener("click", () => startRun());
  btnHow.addEventListener("click", () => {
    menuInfo.textContent =
      "Controles: ESPACIO/‚Üë/toque = salto. R = reintentar. P = pausa. " +
      "Incluye jump buffer y coyote time para que NO haya delay.";
  });

  // Init
  loadLevel(0);
  $attempts.textContent = "0";
  setMode("menu");
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
